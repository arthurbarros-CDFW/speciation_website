{"title":"In-season species proportion","markdown":{"yaml":{"title":"In-season species proportion","bibliography":"references/references.bib","link-citations":true},"headingText":"Simulate counts around the peaks using normal distributions","containsRefs":false,"markdown":"\n\nLet's use our simulated data `daily_sonar` data again, however this time\nour auxiliary counts will be from the same year as our sonar data. This\nmethod determines the proportion of counts for each species in a given\nperiod of sonar data based on the proportions seen in a proximate\n(spatially and temporally) auxiliary data set. This is similar to\nmethods used in @Nolan2023, @Mora2018, and suggested in @Boughton2022.\nThe following simulated data is produced in the same manner as the\nhistorical auxiliary data we created, but this time representing count\ndata collected the same season as our sonar data.\n\n```{r,echo=FALSE,message=FALSE,warning=FALSE}\nlibrary(tidyverse) #for piping and data formatting ease\nlibrary(ggplot2) #for plotting\nlibrary(lubridate) #makes formatting dates a little easier\nlibrary(caret) #provides the createDataPartition() call for testing/training\nlibrary(nnet) #for multi-nomial regression\nlibrary(mclust) #for gaussian mixed models\n\ndaily_sonar<-readRDS(\"data/daily_sonar.rds\")\n```\n\n```{r, aux_sim_current, ,message=FALSE,warning=FALSE}\nset.seed(123)  # For reproducibility\nh_countsA <- round(rnorm(400, mean = as.numeric(as.Date(\"2023-11-20\")),\n                         sd = 20))\nh_countsB <- round(rnorm(325, mean = as.numeric(as.Date(\"2024-01-10\")),\n                         sd = 22))\n\n# Create dataframes, add species columns, and combine in one step\ndate_counts <- bind_rows(\n  as.data.frame(table(as.Date(h_countsA, origin = \"1970-01-01\"))) %>%\n    rename(date = Var1, Count = Freq) %>%\n    mutate(aux_species = \"A\"),\n  as.data.frame(table(as.Date(h_countsB, origin = \"1970-01-01\"))) %>%\n    rename(date = Var1, Count = Freq) %>%\n    mutate(aux_species = \"B\")\n)\n\n# Convert Date column and bin by week\ndate_counts <- date_counts %>%\n  mutate(date = as.Date(date),\n         Week = cut(date, breaks = \"week\", start.on.monday = TRUE))\n\n# Aggregate the counts by week and species\naux_current <- date_counts %>%\n  group_by(Week, aux_species) %>%\n  summarise(Total_Count = sum(Count), .groups = \"drop\") %>%\n  mutate(Week = as.Date(Week))  # Convert Week to Date type for plotting\n```\n\n```{r,hatchery_sim_plot_current,echo=FALSE, fig.cap = \"Plot showing species counts of a current auxiliary catch data set.\"}\n# Plot the results\nggplot(aux_current, aes(x = Week, y = Total_Count, fill = aux_species)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  labs(title = \"Simulated Current Auxiliary Data\",\n       x = \"Week\",\n       y = \"Count\") +\n  scale_fill_manual(values = c('darkorange2','cyan3'),\n                    labels = c('A','B'))+\n  #scale_x_date(date_labels = \"%Y-%m\", date_breaks = \"1 month\") +\n  theme_classic()\n\n```\n\nAgain we can calculate weekly species proportions for our auxiliary\ncount data using the methods detailed in the last section:\n\n```{r, hatchery_current_proportions_1}\n\naux_proportions <- aux_current %>%\n  group_by(Week) %>%\n  mutate(total_n = sum(Total_Count),\n         proportion = Total_Count / total_n) %>%\n  ungroup()\n```\n\nWe can utilize those weekly proportions from the proximate auxiliary\ncounts to assign weekly proportions of species to our sonar count data.\nThis is based on the assumption that the proportion of a given species\nin the sonar count is equal to the proportion of that species in our\nauxiliary data:\n\n$$\nP_{A,i} = \\frac{N_{A,i}}{N_i}\n$$ {#eq-prop}\n\nWhere $P_{A,i}$ is the proportion of species A during period $i$,\n$N_{A,i}$ is the number of fish of species A captured in our auxiliary\ndata set during period $i$, and $N_i$ is the total number of fish\ncaptured in our auxiliary data during period $i$. A side note: if the\nauxiliary data is some distance away from the sonar counts, we may try\nand utilize a lag-time in our proportion estimates, so that the catch at\nthe hatchery during week $i$ is representative sonar data from week\n$i-1$.\n\nStart by joining our simulated `daily_sonar` data to the\n`hatchery_proportions` data we produced.\n\n```{r, sonar_proportion_assignments_1,warning=FALSE,message=FALSE}\ndaily_sonar_nospecies<-daily_sonar%>%\n  group_by(date,Week)%>%\n  summarise(Net_Movement=sum(Net_Movement))\ndaily_sonar_proportions<-daily_sonar_nospecies%>%\n  left_join(aux_proportions,by=\"Week\")\n```\n\nIf you take a look at the `daily_sonar_proportions` data, you'll see\nthat our sonar movement data starts and ends several days outside the\nhatchery count date range. To deal with this we can assume that sonar\nmovement counts before the first week of hatchery data are species A,\nand movement counts after the last week of hatchery data are species B.\nWe can do that with the following code chunk:\n\n```{r, sonar_proportion_assignments_2,warning=FALSE}\n# Identify the first and last hatch dates\nfirst_aux_week <- first(aux_proportions$Week)\nlast_aux_week <- last(aux_proportions$Week)\n\ndaily_sonar_proportions$predicted_species<-NA\n# Assign species based on date conditions\ndaily_sonar_proportions <- daily_sonar_proportions %>%\n  mutate(\n    predicted_species = case_when(\n      is.na(predicted_species) & Week < first_aux_week ~ \"A\",\n      is.na(predicted_species) & Week > last_aux_week ~ \"B\",\n      is.na(predicted_species) ~ aux_species \n    ),\n    proportion = if_else(is.na(proportion), 1, proportion)\n  )\ndaily_sonar_proportions<-daily_sonar_proportions%>%\n  mutate(assigned_count=round(proportion*Net_Movement))\n  \n```\n\nNext we can assign a proportion of each days sonar movement count to\neither of the two species based on the proportion of that species from\nthe hatchery count data for that week.\n\n```{r, sonar_proportion_assignments_3,warnings=FALSE}\n\nweekly_sonar_proportions<-dplyr::select(daily_sonar_proportions,\n                                       Week,date,\n                                       species=predicted_species,\n                                       assigned_count)\n```\n\nPlotting the above data, we get results similar to what we had with the\nin-season cutoff, but here we have proportional data that shows overlap\nin species counts, so that we aren't assuming there is no overlap in run\ntiming.\n\n```{r,prop_assign_plot,echo=FALSE, fig.cap = \"Plot showing species assignments of sonar data using a proportional method\",warnings=FALSE}\n# Plot the results\nggplot(weekly_sonar_proportions, \n       aes(x = Week, y = assigned_count, fill = species)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  labs(title = \"Speciated Sonar Movement Counts\",\n       x = \"Week\",\n       y = \"Net Movement\") +\n  scale_fill_manual(values = c('maroon','darkgreen'),\n                    labels = c('A','B'))+\n  #scale_x_date(date_labels = \"%Y-%m-%d\", date_breaks = \"1 month\") +\n  theme_classic()\n```\n\nThe above method of speciation is still relatively simple in it's\nexecution, and relies on the following assumptions:\n\n-   All fish passing through the sonar site are either one of two\n    species.\n\n-   Auxiliary catch proportions are representative of the true\n    proportions seen in sonar data.\n\nNow we can use the speciation above to estimate our seasonal abundance\nfor each of the two species:\n\n```{r}\nN_est2<-weekly_sonar_proportions%>%\n  group_by(species)%>%\n  summarise(total=sum(assigned_count))\nN_est2\n```\n\nReferencing our original simulated sonar data, we know we had 1000\nindividuals for species A and 850 for species B, so our accuracy in our\nend abundance estimates is pretty good. However we won't know the true\nnumbers when using real data, so we'll need a way to estimate\nuncertainty.\n\n## *Estimating uncertainty*\n\nWe can expand upon the in-season proportion method created above by\nusing iterative \"bootstrapping\" to generate confidence intervals of our\nestimates. This is done iteratively re-sampling our auxiliary hatchery\ncount data to assign species counts to our sonar data. This process is\nrepeated for a set number of iterations to generate variance, which is\nthen used to estimate confidence intervals. One advantage of\nbootstrapping is that it does not rely on assumptions of normality,\nmaking it a robust method for data with unknown distributions.\n\nWe can begin the bootstrapping by writing a function that takes our\nauxiliary species count data (`aux_proportions`) for each week of the\nsonar survey and randomly samples the counts to assign species to the\nsonar movement data. (@fig-bootstrapping_concept).\n\n![Conceptual figure of bootstrapping weekly auxiliary count data to\nproduce variance in species\nassignments.](images/img_bootstrap.png){#fig-bootstrapping_concept\nfig-align=\"center\"}\n\n```{r, bootstrapping_2.1,warnings=FALSE}\nsonar_sampling <- function(daily_sonar, aux_data) {\n  weeks <- unique(daily_sonar$Week)\n  \n  #estimate weekly proportions of auxiliary species counts\n  aux_proportions <- aux_data %>%\n    group_by(Week) %>%\n    mutate(total_n = sum(Total_Count),\n         proportion = Total_Count / total_n) %>%\n    ungroup()\n  \n  # Predefine data frame for results\n  weekly_sonar <- vector(\"list\", length(weeks))\n  \n  # Get boundary weeks for aux_proportions\n  first_aux_week <- min(aux_proportions$Week)\n  last_aux_week <- max(aux_proportions$Week)\n  \n  for (i in seq_along(weeks)) {\n    week <- weeks[i]\n    \n    # Get auxiliary data for the current week\n    wk_sp <- aux_proportions %>% filter(Week == week)\n    wk_sonar <- daily_sonar %>% filter(Week == week)\n    \n    # Create species vector or default to \"A\" or \"B\" based \n    #on week range this is for weeks of sonar data\n    #that don't match up with weeks of aux data\n    sp_vec <- if (nrow(wk_sp) > 0) {\n      rep(wk_sp$aux_species, wk_sp$Total_Count)\n    } else if (week < first_aux_week) {\n      \"A\"\n    } else if (week > last_aux_week) {\n      \"B\"\n    } else {\n      character(0)\n    }\n    \n    # Perform sampling and count occurrences of each species\n    if (length(sp_vec) > 0) {\n      samp_sonar <- sample(sp_vec, sum(wk_sonar$Net_Movement),\n                           replace = TRUE)\n      samp_A <- sum(samp_sonar == \"A\")\n      samp_B <- sum(samp_sonar == \"B\")\n    } else {\n      samp_A <- 0\n      samp_B <- 0\n    }\n    \n    # Store results in a list to avoid repeated data frame binding\n    weekly_sonar[[i]] <- data.frame(Week = week, A = samp_A, B = samp_B)\n  }\n  \n  # Bind the list into a single data frame after the loop\n  weekly_sonar <- do.call(rbind, weekly_sonar)\n  return(weekly_sonar)\n}\n```\n\nThe above function takes our simulated data `daily_sonar` and `aux_data`\nand does the following:\n\n-   Makes a vector listing all the weeks of survey.\n\n-   Calculates the species proportions for each week of the auxiliary\n    data.\n\n-   Runs a `for` loop that assigns a species to sonar counts by sampling\n    from corresponding weeks of the auxiliary data.\n\n-   For weeks of sonar data outside of the range of aux data, the loop\n    assigns species A to early counts, and species B to later counts.\n\nWe can now use the above `sonar_sampling` function to \"bootstrap\" our\ndata to estimate the distribution of our species counts generated with\nsome sampling error. For this example, we repeat the sampling process\nusing our function for 25 iterations in a simple `for` loop. When\nrunning bootstrapping yourself, you'll likely want to aim for 500 to\n1000 iterations, which will take quite a bit longer to run.\n\n```{r, bootstrapping_2.2,warnings=FALSE, message=FALSE}\n\n#bootstrapping boogie\niterations<-100\nresults<-data.frame()\n\nfor(j in 1:iterations){\n  iter<-data.frame('iteration'=j)\n  d<-iter%>%cbind(sonar_sampling(daily_sonar,aux_current))\n  results<-results%>%rbind(d)\n}\n\nhead(results)\n```\n\nThe `results` output of our bootstrapping shows weekly species counts\nfor sonar data produced by our random sampling of auxiliary data. We can\ngroup the results together by iteration for an estimate of species total\nfor each season, and then calculate lower and upper 95% confidence\nintervals using the `quantile()` call.\n\n```{r, bootstrapping_2.3,warnings=FALSE}\n#iteration total estimates\niter_totals<-results%>%\n  group_by(iteration)%>%\n  dplyr::summarise(A=sum(A),\n                   B=sum(B))\n\n#bounds\nA_stats <- quantile(iter_totals$A, probs = c(0.025, 0.975))\nB_stats <- quantile(iter_totals$B, probs = c(0.025, 0.975))\nA_mean<-mean(iter_totals$A)\nB_mean<-mean(iter_totals$B)\n```\n\nUsing the above we see that our **estimate of total abundance of species\nA in our sonar counts is `r N_est2[1,2]` with 95% CI\n\\[`r ceiling(A_stats[1])`, `r ceiling(A_stats[2])`\\] and a count of\n`r N_est2[2,2]` with 95% CI \\[`r ceiling(B_stats[1])`,\n`r ceiling(B_stats[2])`\\] for species B**.\n\nWe can also estimate 95% confidence intervals for our weekly species\nassignments using the results output.\n\n```{r, bootstrapping_2.4,warnings=FALSE}\n# Weekly total estimates with confidence intervals\nweekly_results <- results %>%\n  group_by(Week) %>%\n  summarise(\n    A_mean = mean(A),\n    A_lb = quantile(A, probs = 0.025),\n    A_ub = quantile(A, probs = 0.975),\n    B_mean = mean(B),\n    B_lb = quantile(B, probs = 0.025),\n    B_ub = quantile(B, probs = 0.975),\n    .groups = \"drop\"\n  ) %>%\n  pivot_longer(\n  cols = 2:7,\n  names_to = c(\"Species\", \".value\"),\n  names_sep = \"_\")\n```\n\n```{r, boots_2.5_plot,echo=FALSE, fig.cap = \"Plot showing species assignments of sonar data using proportional bootstrapping to estimate confidence intervals (95%).\"}\n# Create the plot\nggplot(weekly_results, aes(x = Week, y = mean, fill = Species)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  geom_errorbar(\n    aes(ymin = lb, ymax = ub),\n    position = position_dodge()\n  ) +\n  labs(\n    title = \"Weekly Species Estimates with 95% Confidence Intervals\",\n    x = \"Week\",\n    y = \"Mean Count\",\n    fill = \"Species\"\n  ) +\n  theme_classic() +\n  scale_fill_manual(values = c('maroon','darkgreen'),\n                    labels = c('A','B'))\n```\n\nThe above figure shows that during periods of run-timing overlap, our\nprecision in estimation of species assignment decreases substantially.\nThe more overlap in run-timing, the more bias we can expect in our\nspeciation.\n\nThe above method of speciation provides a straightforward approach for\nleveraging more contemporary auxiliary data to infer species composition\nin sonar detection studies. Using the species proportions from this\nauxiliary data set we assign species proportions to sonar data, and can\niteratively resample the data through \"bootstraping\" to estimate\nconfidence intervals. Key assumptions to realize when utilizing this\nmethod are:\n\n-   All fish being speciated are either one of two species.\n\n-   Species proportions in the auxiliary data is representative of the\n    fish community at the sonar site.\n\nWhen considering auxiliary data sets to use for informing species\napportionment, the more proximate the data to the sonar site, the more\naccurate species assignments will likely be.\n\n","srcMarkdownNoYaml":"\n\nLet's use our simulated data `daily_sonar` data again, however this time\nour auxiliary counts will be from the same year as our sonar data. This\nmethod determines the proportion of counts for each species in a given\nperiod of sonar data based on the proportions seen in a proximate\n(spatially and temporally) auxiliary data set. This is similar to\nmethods used in @Nolan2023, @Mora2018, and suggested in @Boughton2022.\nThe following simulated data is produced in the same manner as the\nhistorical auxiliary data we created, but this time representing count\ndata collected the same season as our sonar data.\n\n```{r,echo=FALSE,message=FALSE,warning=FALSE}\nlibrary(tidyverse) #for piping and data formatting ease\nlibrary(ggplot2) #for plotting\nlibrary(lubridate) #makes formatting dates a little easier\nlibrary(caret) #provides the createDataPartition() call for testing/training\nlibrary(nnet) #for multi-nomial regression\nlibrary(mclust) #for gaussian mixed models\n\ndaily_sonar<-readRDS(\"data/daily_sonar.rds\")\n```\n\n```{r, aux_sim_current, ,message=FALSE,warning=FALSE}\nset.seed(123)  # For reproducibility\n# Simulate counts around the peaks using normal distributions\nh_countsA <- round(rnorm(400, mean = as.numeric(as.Date(\"2023-11-20\")),\n                         sd = 20))\nh_countsB <- round(rnorm(325, mean = as.numeric(as.Date(\"2024-01-10\")),\n                         sd = 22))\n\n# Create dataframes, add species columns, and combine in one step\ndate_counts <- bind_rows(\n  as.data.frame(table(as.Date(h_countsA, origin = \"1970-01-01\"))) %>%\n    rename(date = Var1, Count = Freq) %>%\n    mutate(aux_species = \"A\"),\n  as.data.frame(table(as.Date(h_countsB, origin = \"1970-01-01\"))) %>%\n    rename(date = Var1, Count = Freq) %>%\n    mutate(aux_species = \"B\")\n)\n\n# Convert Date column and bin by week\ndate_counts <- date_counts %>%\n  mutate(date = as.Date(date),\n         Week = cut(date, breaks = \"week\", start.on.monday = TRUE))\n\n# Aggregate the counts by week and species\naux_current <- date_counts %>%\n  group_by(Week, aux_species) %>%\n  summarise(Total_Count = sum(Count), .groups = \"drop\") %>%\n  mutate(Week = as.Date(Week))  # Convert Week to Date type for plotting\n```\n\n```{r,hatchery_sim_plot_current,echo=FALSE, fig.cap = \"Plot showing species counts of a current auxiliary catch data set.\"}\n# Plot the results\nggplot(aux_current, aes(x = Week, y = Total_Count, fill = aux_species)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  labs(title = \"Simulated Current Auxiliary Data\",\n       x = \"Week\",\n       y = \"Count\") +\n  scale_fill_manual(values = c('darkorange2','cyan3'),\n                    labels = c('A','B'))+\n  #scale_x_date(date_labels = \"%Y-%m\", date_breaks = \"1 month\") +\n  theme_classic()\n\n```\n\nAgain we can calculate weekly species proportions for our auxiliary\ncount data using the methods detailed in the last section:\n\n```{r, hatchery_current_proportions_1}\n\naux_proportions <- aux_current %>%\n  group_by(Week) %>%\n  mutate(total_n = sum(Total_Count),\n         proportion = Total_Count / total_n) %>%\n  ungroup()\n```\n\nWe can utilize those weekly proportions from the proximate auxiliary\ncounts to assign weekly proportions of species to our sonar count data.\nThis is based on the assumption that the proportion of a given species\nin the sonar count is equal to the proportion of that species in our\nauxiliary data:\n\n$$\nP_{A,i} = \\frac{N_{A,i}}{N_i}\n$$ {#eq-prop}\n\nWhere $P_{A,i}$ is the proportion of species A during period $i$,\n$N_{A,i}$ is the number of fish of species A captured in our auxiliary\ndata set during period $i$, and $N_i$ is the total number of fish\ncaptured in our auxiliary data during period $i$. A side note: if the\nauxiliary data is some distance away from the sonar counts, we may try\nand utilize a lag-time in our proportion estimates, so that the catch at\nthe hatchery during week $i$ is representative sonar data from week\n$i-1$.\n\nStart by joining our simulated `daily_sonar` data to the\n`hatchery_proportions` data we produced.\n\n```{r, sonar_proportion_assignments_1,warning=FALSE,message=FALSE}\ndaily_sonar_nospecies<-daily_sonar%>%\n  group_by(date,Week)%>%\n  summarise(Net_Movement=sum(Net_Movement))\ndaily_sonar_proportions<-daily_sonar_nospecies%>%\n  left_join(aux_proportions,by=\"Week\")\n```\n\nIf you take a look at the `daily_sonar_proportions` data, you'll see\nthat our sonar movement data starts and ends several days outside the\nhatchery count date range. To deal with this we can assume that sonar\nmovement counts before the first week of hatchery data are species A,\nand movement counts after the last week of hatchery data are species B.\nWe can do that with the following code chunk:\n\n```{r, sonar_proportion_assignments_2,warning=FALSE}\n# Identify the first and last hatch dates\nfirst_aux_week <- first(aux_proportions$Week)\nlast_aux_week <- last(aux_proportions$Week)\n\ndaily_sonar_proportions$predicted_species<-NA\n# Assign species based on date conditions\ndaily_sonar_proportions <- daily_sonar_proportions %>%\n  mutate(\n    predicted_species = case_when(\n      is.na(predicted_species) & Week < first_aux_week ~ \"A\",\n      is.na(predicted_species) & Week > last_aux_week ~ \"B\",\n      is.na(predicted_species) ~ aux_species \n    ),\n    proportion = if_else(is.na(proportion), 1, proportion)\n  )\ndaily_sonar_proportions<-daily_sonar_proportions%>%\n  mutate(assigned_count=round(proportion*Net_Movement))\n  \n```\n\nNext we can assign a proportion of each days sonar movement count to\neither of the two species based on the proportion of that species from\nthe hatchery count data for that week.\n\n```{r, sonar_proportion_assignments_3,warnings=FALSE}\n\nweekly_sonar_proportions<-dplyr::select(daily_sonar_proportions,\n                                       Week,date,\n                                       species=predicted_species,\n                                       assigned_count)\n```\n\nPlotting the above data, we get results similar to what we had with the\nin-season cutoff, but here we have proportional data that shows overlap\nin species counts, so that we aren't assuming there is no overlap in run\ntiming.\n\n```{r,prop_assign_plot,echo=FALSE, fig.cap = \"Plot showing species assignments of sonar data using a proportional method\",warnings=FALSE}\n# Plot the results\nggplot(weekly_sonar_proportions, \n       aes(x = Week, y = assigned_count, fill = species)) +\n  geom_bar(stat = \"identity\", position = \"stack\") +\n  labs(title = \"Speciated Sonar Movement Counts\",\n       x = \"Week\",\n       y = \"Net Movement\") +\n  scale_fill_manual(values = c('maroon','darkgreen'),\n                    labels = c('A','B'))+\n  #scale_x_date(date_labels = \"%Y-%m-%d\", date_breaks = \"1 month\") +\n  theme_classic()\n```\n\nThe above method of speciation is still relatively simple in it's\nexecution, and relies on the following assumptions:\n\n-   All fish passing through the sonar site are either one of two\n    species.\n\n-   Auxiliary catch proportions are representative of the true\n    proportions seen in sonar data.\n\nNow we can use the speciation above to estimate our seasonal abundance\nfor each of the two species:\n\n```{r}\nN_est2<-weekly_sonar_proportions%>%\n  group_by(species)%>%\n  summarise(total=sum(assigned_count))\nN_est2\n```\n\nReferencing our original simulated sonar data, we know we had 1000\nindividuals for species A and 850 for species B, so our accuracy in our\nend abundance estimates is pretty good. However we won't know the true\nnumbers when using real data, so we'll need a way to estimate\nuncertainty.\n\n## *Estimating uncertainty*\n\nWe can expand upon the in-season proportion method created above by\nusing iterative \"bootstrapping\" to generate confidence intervals of our\nestimates. This is done iteratively re-sampling our auxiliary hatchery\ncount data to assign species counts to our sonar data. This process is\nrepeated for a set number of iterations to generate variance, which is\nthen used to estimate confidence intervals. One advantage of\nbootstrapping is that it does not rely on assumptions of normality,\nmaking it a robust method for data with unknown distributions.\n\nWe can begin the bootstrapping by writing a function that takes our\nauxiliary species count data (`aux_proportions`) for each week of the\nsonar survey and randomly samples the counts to assign species to the\nsonar movement data. (@fig-bootstrapping_concept).\n\n![Conceptual figure of bootstrapping weekly auxiliary count data to\nproduce variance in species\nassignments.](images/img_bootstrap.png){#fig-bootstrapping_concept\nfig-align=\"center\"}\n\n```{r, bootstrapping_2.1,warnings=FALSE}\nsonar_sampling <- function(daily_sonar, aux_data) {\n  weeks <- unique(daily_sonar$Week)\n  \n  #estimate weekly proportions of auxiliary species counts\n  aux_proportions <- aux_data %>%\n    group_by(Week) %>%\n    mutate(total_n = sum(Total_Count),\n         proportion = Total_Count / total_n) %>%\n    ungroup()\n  \n  # Predefine data frame for results\n  weekly_sonar <- vector(\"list\", length(weeks))\n  \n  # Get boundary weeks for aux_proportions\n  first_aux_week <- min(aux_proportions$Week)\n  last_aux_week <- max(aux_proportions$Week)\n  \n  for (i in seq_along(weeks)) {\n    week <- weeks[i]\n    \n    # Get auxiliary data for the current week\n    wk_sp <- aux_proportions %>% filter(Week == week)\n    wk_sonar <- daily_sonar %>% filter(Week == week)\n    \n    # Create species vector or default to \"A\" or \"B\" based \n    #on week range this is for weeks of sonar data\n    #that don't match up with weeks of aux data\n    sp_vec <- if (nrow(wk_sp) > 0) {\n      rep(wk_sp$aux_species, wk_sp$Total_Count)\n    } else if (week < first_aux_week) {\n      \"A\"\n    } else if (week > last_aux_week) {\n      \"B\"\n    } else {\n      character(0)\n    }\n    \n    # Perform sampling and count occurrences of each species\n    if (length(sp_vec) > 0) {\n      samp_sonar <- sample(sp_vec, sum(wk_sonar$Net_Movement),\n                           replace = TRUE)\n      samp_A <- sum(samp_sonar == \"A\")\n      samp_B <- sum(samp_sonar == \"B\")\n    } else {\n      samp_A <- 0\n      samp_B <- 0\n    }\n    \n    # Store results in a list to avoid repeated data frame binding\n    weekly_sonar[[i]] <- data.frame(Week = week, A = samp_A, B = samp_B)\n  }\n  \n  # Bind the list into a single data frame after the loop\n  weekly_sonar <- do.call(rbind, weekly_sonar)\n  return(weekly_sonar)\n}\n```\n\nThe above function takes our simulated data `daily_sonar` and `aux_data`\nand does the following:\n\n-   Makes a vector listing all the weeks of survey.\n\n-   Calculates the species proportions for each week of the auxiliary\n    data.\n\n-   Runs a `for` loop that assigns a species to sonar counts by sampling\n    from corresponding weeks of the auxiliary data.\n\n-   For weeks of sonar data outside of the range of aux data, the loop\n    assigns species A to early counts, and species B to later counts.\n\nWe can now use the above `sonar_sampling` function to \"bootstrap\" our\ndata to estimate the distribution of our species counts generated with\nsome sampling error. For this example, we repeat the sampling process\nusing our function for 25 iterations in a simple `for` loop. When\nrunning bootstrapping yourself, you'll likely want to aim for 500 to\n1000 iterations, which will take quite a bit longer to run.\n\n```{r, bootstrapping_2.2,warnings=FALSE, message=FALSE}\n\n#bootstrapping boogie\niterations<-100\nresults<-data.frame()\n\nfor(j in 1:iterations){\n  iter<-data.frame('iteration'=j)\n  d<-iter%>%cbind(sonar_sampling(daily_sonar,aux_current))\n  results<-results%>%rbind(d)\n}\n\nhead(results)\n```\n\nThe `results` output of our bootstrapping shows weekly species counts\nfor sonar data produced by our random sampling of auxiliary data. We can\ngroup the results together by iteration for an estimate of species total\nfor each season, and then calculate lower and upper 95% confidence\nintervals using the `quantile()` call.\n\n```{r, bootstrapping_2.3,warnings=FALSE}\n#iteration total estimates\niter_totals<-results%>%\n  group_by(iteration)%>%\n  dplyr::summarise(A=sum(A),\n                   B=sum(B))\n\n#bounds\nA_stats <- quantile(iter_totals$A, probs = c(0.025, 0.975))\nB_stats <- quantile(iter_totals$B, probs = c(0.025, 0.975))\nA_mean<-mean(iter_totals$A)\nB_mean<-mean(iter_totals$B)\n```\n\nUsing the above we see that our **estimate of total abundance of species\nA in our sonar counts is `r N_est2[1,2]` with 95% CI\n\\[`r ceiling(A_stats[1])`, `r ceiling(A_stats[2])`\\] and a count of\n`r N_est2[2,2]` with 95% CI \\[`r ceiling(B_stats[1])`,\n`r ceiling(B_stats[2])`\\] for species B**.\n\nWe can also estimate 95% confidence intervals for our weekly species\nassignments using the results output.\n\n```{r, bootstrapping_2.4,warnings=FALSE}\n# Weekly total estimates with confidence intervals\nweekly_results <- results %>%\n  group_by(Week) %>%\n  summarise(\n    A_mean = mean(A),\n    A_lb = quantile(A, probs = 0.025),\n    A_ub = quantile(A, probs = 0.975),\n    B_mean = mean(B),\n    B_lb = quantile(B, probs = 0.025),\n    B_ub = quantile(B, probs = 0.975),\n    .groups = \"drop\"\n  ) %>%\n  pivot_longer(\n  cols = 2:7,\n  names_to = c(\"Species\", \".value\"),\n  names_sep = \"_\")\n```\n\n```{r, boots_2.5_plot,echo=FALSE, fig.cap = \"Plot showing species assignments of sonar data using proportional bootstrapping to estimate confidence intervals (95%).\"}\n# Create the plot\nggplot(weekly_results, aes(x = Week, y = mean, fill = Species)) +\n  geom_bar(stat = \"identity\", position = \"dodge\") +\n  geom_errorbar(\n    aes(ymin = lb, ymax = ub),\n    position = position_dodge()\n  ) +\n  labs(\n    title = \"Weekly Species Estimates with 95% Confidence Intervals\",\n    x = \"Week\",\n    y = \"Mean Count\",\n    fill = \"Species\"\n  ) +\n  theme_classic() +\n  scale_fill_manual(values = c('maroon','darkgreen'),\n                    labels = c('A','B'))\n```\n\nThe above figure shows that during periods of run-timing overlap, our\nprecision in estimation of species assignment decreases substantially.\nThe more overlap in run-timing, the more bias we can expect in our\nspeciation.\n\nThe above method of speciation provides a straightforward approach for\nleveraging more contemporary auxiliary data to infer species composition\nin sonar detection studies. Using the species proportions from this\nauxiliary data set we assign species proportions to sonar data, and can\niteratively resample the data through \"bootstraping\" to estimate\nconfidence intervals. Key assumptions to realize when utilizing this\nmethod are:\n\n-   All fish being speciated are either one of two species.\n\n-   Species proportions in the auxiliary data is representative of the\n    fish community at the sonar site.\n\nWhen considering auxiliary data sets to use for informing species\napportionment, the more proximate the data to the sonar site, the more\naccurate species assignments will likely be.\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"inseason_proportion.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.433","editor":"visual","theme":"cosmo","title":"In-season species proportion","bibliography":["references/references.bib"],"link-citations":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}