{"title":"Gaussian Mixed Modelling","markdown":{"yaml":{"title":"Gaussian Mixed Modelling","bibliography":"references/references.bib","link-citations":true},"headingText":"Gaussian Mixed model apportionment","containsRefs":false,"markdown":"\n```{r,echo=FALSE,message=FALSE,warning=FALSE}\nlibrary(tidyverse) #for piping and data formatting ease\nlibrary(ggplot2) #for plotting\nlibrary(lubridate) #makes formatting dates a little easier\nlibrary(caret) #provides the createDataPartition() call for testing/training\nlibrary(nnet) #for multi-nomial regression\nlibrary(mclust) #for gaussian mixed models\n\nsonar_data<-readRDS(\"data/sonar_data2.rds\")\naux_data<-readRDS(\"data/aux_data2.rds\")\nflow_df<-readRDS(\"data/flow_df.rds\")\n```\n\n\nAn alternative to the logistic models is called a \"Guassian Mixed Model\"\n(GMM). The logistic regression models used previously involve assigning\nindividuals to one species or another based on whether or not the\nprobability exceeds a threshold. When their is a lot of overlap in\ndistribution of lengths or dates, this species assignment method is\nsubject to bias, especially when proportions of a given species are\nrelatively one-sided [@Fleischman2003]. While a GMM approach may not be\nas easily interpretable as the logistic regressions, and rely on an\nassumption of normality, they can handle uncertainty better, especially\nwhen dealing with significant overlap in species length and timing\ndistributions.\n\nA general equation of the GMM utilized is:\n\n$$f(x,y)=\\sum_{k=1}^{K}\\pi_k*N((x,y)|\\mu_k,\\sigma_k^2) $$\n\nThe above gives the probability density function of a dataset as a\nweighted sum of multiple Gaussian (normal) distributions. Each component\n$k$ represents a cluster in the data,of which there are a total of $K$,\nfor our example we expect 3 clusters for species \"A\", \"B\", and \"C\".\n$(x,y)$ are the observed data points (in our case length and date), and\n$\\pi_k$ is the mixing proportion for component $k$, which all sum to 1.\n$N((x,y)|\\mu_k,\\sigma_k^2)$ represents the Gaussian distribution for\neach of the $k$-th components with a mean of $\\mu_k$ and a variance of\n$\\sigma_k^2$.\n\nFor our demonstration, we can use the same auxiliary and sonar data sets\nthat we've already simulated before, and see how the GMM compares to the\nlogistic regression methods we've used. We've already seen the\ndistributions of these data, but we can visualize the 2D distribution as\nwell:\n\n```{r,echo=FALSE,fig.height=4,fig.width=5, fig.cap = \"Plot of the 2D distributions of auxiliary data with species identities.\",warnings=FALSE,messages=FALSE}\ncols=c('A'='maroon','B'='darkblue','C'='darkgreen')\nshapes=c('A'=16,'B'=17,'C'=18)\nggplot(aux_data, aes(x=length, y=as.Date(date,origin=\"1970-01-01\"),\n                     color=species, shape=species)) +\n  geom_point(size=3) +\n  scale_color_manual(values = cols)+\n  scale_shape_manual(values = shapes)+\n  labs(title=\"Auxiliary data\", x=\"Length\", y=\"Date\") +\n  theme_classic()\n```\n\nWith the above plot we can see distinct clusters of dates and lengths,\nwith some overlap between species.\n\nWe'll start by loading the `mclust` package to utilize their `Mclust()`\ncall to run a GMM on our data, and testing the model on the auxiliary\ndata in the same way we've used in before. Note that in this for-loop,\ninstead of using the predict function to set a given species ID based on\na probability threshold, I'm estimating the abundance by summing the\ntotal probability for each species and using that as our abundance\nestimate.\n\n```{r, gaus_m_model,warnings=FALSE,messages=FALSE}\n\nset.seed(Sys.time()) #reset seed\niterations=100\nresults<-data.frame()\ngmm_data<-select(aux_data,length,date,Flow_cfs,species)\n#note here that the Mclust requires date in a numeric format\ngmm_data$num_date<-as.numeric(gmm_data$date) \nfor(i in 1:iterations){\n  train_index <- createDataPartition(gmm_data$species, p = 0.7, list = FALSE) \n  train_data <- gmm_data[train_index, ]\n  test_data <- gmm_data[-train_index, ]\n  \n  Ntrue_A<-sum(test_data$species==\"A\")\n  Ntrue_B<-sum(test_data$species==\"B\")\n  Ntrue_C<-sum(test_data$species==\"C\")\n  \n  #Fit a Gaussian Mixture Model to the training data \n  model_iter <- Mclust(train_data[, c(\"length\", \"num_date\")], G=3)\n  \n  #summary(model_iter)\n  # Predict species for the test data based on the trained model\n  predictions <- predict(model_iter, test_data[, c(\"length\", \"num_date\")])\n  test_data$species_predicted <- factor(predictions$classification,\n                                        levels = 1:3, labels = c(\"A\",\"B\",\"C\"))\n  \n  accuracy <- sum(test_data$species_predicted == \n                    test_data$species)/nrow(test_data)\n  \n  #Change in abundance estimate:\n  #here I can sum the probability for each classification to \n  #estimate total abundance\n  #instead of using the threshold classification method\n  Nest_A<-sum(predictions$z[,1])\n  Nest_B<-sum(predictions$z[,2])\n  Nest_C<-sum(predictions$z[,3])\n\n  error_A <- abs(Nest_A - Ntrue_A)\n  error_B <- abs(Nest_B - Ntrue_B)\n  error_C <- abs(Nest_C - Ntrue_C)\n\n  rel_error_A <- error_A / Ntrue_A\n  rel_error_B <- error_B / Ntrue_B\n  rel_error_C <- error_C / Ntrue_C\n  \n  MAPE <- mean(c(rel_error_A, rel_error_B, rel_error_C)) * 100\n  d<-data.frame(\"accuracy\"=accuracy,\"MAPE\"=MAPE)\n  \n  results<-results%>%rbind(d)\n}\n```\n\nBased on the above model training and iterative testing, we see our\nmodel predicted the species of our test data with an average accuracy of\n`r round(mean(results$accuracy), 3)`, and estimated species abundance\nwith an average error of `r round(mean(results$MAPE),3)`.\n\nNow we can retrain our model using the entire auxiliary data set, and\nuse it to predict species counts for our sonar_data.\n\n```{r}\nmodel_3<-Mclust(gmm_data[, c(\"length\", \"num_date\")], G=3)\n#note here that the Mclust requires date in a numeric format\nsonar_data$num_date<-as.numeric(sonar_data$date)\npredictions <- predict(model_3, sonar_data[, c(\"length\", \"num_date\")])\nsonar_data$species_predicted <- factor(predictions$classification,\n                                       levels = 1:3, labels = c(\"A\",\"B\",\"C\"))\n```\n\nWe can plot our predicted species to see if the clustering generally\nfits that of our auxiliary data.\n\n```{r,echo=FALSE,fig.height=4,fig.width=5, fig.cap = \"Plot of the 2D distributions of sonar data with predicted species identities.\",warnings=FALSE,messages=FALSE}\ncols=c('A'='maroon','B'='darkblue','C'='darkgreen')\nshapes=c('A'=16,'B'=17,'C'=18)\nggplot(sonar_data, aes(x=length, y=as.Date(date,origin=\"1970-01-01\"),\n                     color=species_predicted, shape=species_predicted)) +\n  geom_point(size=3) +\n  scale_color_manual(values = cols)+\n  scale_shape_manual(values = shapes)+\n  labs(title=\"Sonar data\", x=\"Length\", y=\"Date\") +\n  theme_classic()\n```\n\nNow, instead of using the assigned species values, we'll use the\nprobability each fish is a given species, which will give us a total\nestimate of abundance. If we look at the `predictions$z` we see a record\nfor each observation that gives the probability it is one of the three\nclasses based on the model predictions.\n\n```{r}\nhead(predictions$z)\n```\n\nWe can take the sum of each column to estimate the abundance of each\nspecies here:\n\n```{r}\nNest_A<-round(sum(predictions$z[,1]))\nNest_B<-round(sum(predictions$z[,2]))\nNest_C<-round(sum(predictions$z[,3]))\n```\n\nOur estimates of abundance in this example are `r Nest_A` for species A,\n`r Nest_B` for species B, and `r Nest_C` for species C.\n\n## *Estimating uncertainty*\n\nAgain we can replicate our bootstrapping methods we used to estimate\nuncertainty in prior methods.\n\n```{r,warnings=FALSE,message=FALSE,results=\"hide\"}\n#bootstrapping boogie\niterations<-100\nresults<-data.frame()\n\nfor(j in 1:iterations){\n  d <- sonar_data[sample(nrow(sonar_data), replace = TRUE), ]\n  predictions <- predict(model_3, d[, c(\"length\", \"num_date\")])\n  d$species_predicted <- factor(predictions$classification,\n                                       levels = 1:3, labels = c(\"A\",\"B\",\"C\"))\n  \n  N_A<-sum(predictions$z[,1])\n  N_B<-sum(predictions$z[,2])\n  N_C<-sum(predictions$z[,3])\n  iter<-data.frame('iteration'=j,\"A\"=N_A[1],\"B\"=N_B[1],\"C\"=N_C[1])\n  results<-results%>%rbind(iter)\n}\n\n#iteration total estimates\niter_totals<-results%>%\n  group_by(iteration)%>%\n  dplyr::summarise(A=sum(A),\n                   B=sum(B),\n                   C=sum(C))\n\n#bounds\nA_stats <- quantile(iter_totals$A, probs = c(0.025, 0.975))\nB_stats <- quantile(iter_totals$B, probs = c(0.025, 0.975))\nC_stats <- quantile(iter_totals$C, probs = c(0.025, 0.975))\n```\n\nThe above results show that our estimate of total abundance of species A\nin our sonar counts is `r Nest_A` with 95% CI \\[`r ceiling(A_stats[1])`,\n`r ceiling(A_stats[2])`\\], a count of `r Nest_B` with 95% CI\n\\[`r ceiling(B_stats[1])`, `r ceiling(B_stats[2])`\\] for species B, and\na count of `r Nest_C` with 95% CI \\[`r ceiling(C_stats[1])`,\n`r ceiling(C_stats[2])`\\] for species C.\n","srcMarkdownNoYaml":"\n```{r,echo=FALSE,message=FALSE,warning=FALSE}\nlibrary(tidyverse) #for piping and data formatting ease\nlibrary(ggplot2) #for plotting\nlibrary(lubridate) #makes formatting dates a little easier\nlibrary(caret) #provides the createDataPartition() call for testing/training\nlibrary(nnet) #for multi-nomial regression\nlibrary(mclust) #for gaussian mixed models\n\nsonar_data<-readRDS(\"data/sonar_data2.rds\")\naux_data<-readRDS(\"data/aux_data2.rds\")\nflow_df<-readRDS(\"data/flow_df.rds\")\n```\n\n# Gaussian Mixed model apportionment\n\nAn alternative to the logistic models is called a \"Guassian Mixed Model\"\n(GMM). The logistic regression models used previously involve assigning\nindividuals to one species or another based on whether or not the\nprobability exceeds a threshold. When their is a lot of overlap in\ndistribution of lengths or dates, this species assignment method is\nsubject to bias, especially when proportions of a given species are\nrelatively one-sided [@Fleischman2003]. While a GMM approach may not be\nas easily interpretable as the logistic regressions, and rely on an\nassumption of normality, they can handle uncertainty better, especially\nwhen dealing with significant overlap in species length and timing\ndistributions.\n\nA general equation of the GMM utilized is:\n\n$$f(x,y)=\\sum_{k=1}^{K}\\pi_k*N((x,y)|\\mu_k,\\sigma_k^2) $$\n\nThe above gives the probability density function of a dataset as a\nweighted sum of multiple Gaussian (normal) distributions. Each component\n$k$ represents a cluster in the data,of which there are a total of $K$,\nfor our example we expect 3 clusters for species \"A\", \"B\", and \"C\".\n$(x,y)$ are the observed data points (in our case length and date), and\n$\\pi_k$ is the mixing proportion for component $k$, which all sum to 1.\n$N((x,y)|\\mu_k,\\sigma_k^2)$ represents the Gaussian distribution for\neach of the $k$-th components with a mean of $\\mu_k$ and a variance of\n$\\sigma_k^2$.\n\nFor our demonstration, we can use the same auxiliary and sonar data sets\nthat we've already simulated before, and see how the GMM compares to the\nlogistic regression methods we've used. We've already seen the\ndistributions of these data, but we can visualize the 2D distribution as\nwell:\n\n```{r,echo=FALSE,fig.height=4,fig.width=5, fig.cap = \"Plot of the 2D distributions of auxiliary data with species identities.\",warnings=FALSE,messages=FALSE}\ncols=c('A'='maroon','B'='darkblue','C'='darkgreen')\nshapes=c('A'=16,'B'=17,'C'=18)\nggplot(aux_data, aes(x=length, y=as.Date(date,origin=\"1970-01-01\"),\n                     color=species, shape=species)) +\n  geom_point(size=3) +\n  scale_color_manual(values = cols)+\n  scale_shape_manual(values = shapes)+\n  labs(title=\"Auxiliary data\", x=\"Length\", y=\"Date\") +\n  theme_classic()\n```\n\nWith the above plot we can see distinct clusters of dates and lengths,\nwith some overlap between species.\n\nWe'll start by loading the `mclust` package to utilize their `Mclust()`\ncall to run a GMM on our data, and testing the model on the auxiliary\ndata in the same way we've used in before. Note that in this for-loop,\ninstead of using the predict function to set a given species ID based on\na probability threshold, I'm estimating the abundance by summing the\ntotal probability for each species and using that as our abundance\nestimate.\n\n```{r, gaus_m_model,warnings=FALSE,messages=FALSE}\n\nset.seed(Sys.time()) #reset seed\niterations=100\nresults<-data.frame()\ngmm_data<-select(aux_data,length,date,Flow_cfs,species)\n#note here that the Mclust requires date in a numeric format\ngmm_data$num_date<-as.numeric(gmm_data$date) \nfor(i in 1:iterations){\n  train_index <- createDataPartition(gmm_data$species, p = 0.7, list = FALSE) \n  train_data <- gmm_data[train_index, ]\n  test_data <- gmm_data[-train_index, ]\n  \n  Ntrue_A<-sum(test_data$species==\"A\")\n  Ntrue_B<-sum(test_data$species==\"B\")\n  Ntrue_C<-sum(test_data$species==\"C\")\n  \n  #Fit a Gaussian Mixture Model to the training data \n  model_iter <- Mclust(train_data[, c(\"length\", \"num_date\")], G=3)\n  \n  #summary(model_iter)\n  # Predict species for the test data based on the trained model\n  predictions <- predict(model_iter, test_data[, c(\"length\", \"num_date\")])\n  test_data$species_predicted <- factor(predictions$classification,\n                                        levels = 1:3, labels = c(\"A\",\"B\",\"C\"))\n  \n  accuracy <- sum(test_data$species_predicted == \n                    test_data$species)/nrow(test_data)\n  \n  #Change in abundance estimate:\n  #here I can sum the probability for each classification to \n  #estimate total abundance\n  #instead of using the threshold classification method\n  Nest_A<-sum(predictions$z[,1])\n  Nest_B<-sum(predictions$z[,2])\n  Nest_C<-sum(predictions$z[,3])\n\n  error_A <- abs(Nest_A - Ntrue_A)\n  error_B <- abs(Nest_B - Ntrue_B)\n  error_C <- abs(Nest_C - Ntrue_C)\n\n  rel_error_A <- error_A / Ntrue_A\n  rel_error_B <- error_B / Ntrue_B\n  rel_error_C <- error_C / Ntrue_C\n  \n  MAPE <- mean(c(rel_error_A, rel_error_B, rel_error_C)) * 100\n  d<-data.frame(\"accuracy\"=accuracy,\"MAPE\"=MAPE)\n  \n  results<-results%>%rbind(d)\n}\n```\n\nBased on the above model training and iterative testing, we see our\nmodel predicted the species of our test data with an average accuracy of\n`r round(mean(results$accuracy), 3)`, and estimated species abundance\nwith an average error of `r round(mean(results$MAPE),3)`.\n\nNow we can retrain our model using the entire auxiliary data set, and\nuse it to predict species counts for our sonar_data.\n\n```{r}\nmodel_3<-Mclust(gmm_data[, c(\"length\", \"num_date\")], G=3)\n#note here that the Mclust requires date in a numeric format\nsonar_data$num_date<-as.numeric(sonar_data$date)\npredictions <- predict(model_3, sonar_data[, c(\"length\", \"num_date\")])\nsonar_data$species_predicted <- factor(predictions$classification,\n                                       levels = 1:3, labels = c(\"A\",\"B\",\"C\"))\n```\n\nWe can plot our predicted species to see if the clustering generally\nfits that of our auxiliary data.\n\n```{r,echo=FALSE,fig.height=4,fig.width=5, fig.cap = \"Plot of the 2D distributions of sonar data with predicted species identities.\",warnings=FALSE,messages=FALSE}\ncols=c('A'='maroon','B'='darkblue','C'='darkgreen')\nshapes=c('A'=16,'B'=17,'C'=18)\nggplot(sonar_data, aes(x=length, y=as.Date(date,origin=\"1970-01-01\"),\n                     color=species_predicted, shape=species_predicted)) +\n  geom_point(size=3) +\n  scale_color_manual(values = cols)+\n  scale_shape_manual(values = shapes)+\n  labs(title=\"Sonar data\", x=\"Length\", y=\"Date\") +\n  theme_classic()\n```\n\nNow, instead of using the assigned species values, we'll use the\nprobability each fish is a given species, which will give us a total\nestimate of abundance. If we look at the `predictions$z` we see a record\nfor each observation that gives the probability it is one of the three\nclasses based on the model predictions.\n\n```{r}\nhead(predictions$z)\n```\n\nWe can take the sum of each column to estimate the abundance of each\nspecies here:\n\n```{r}\nNest_A<-round(sum(predictions$z[,1]))\nNest_B<-round(sum(predictions$z[,2]))\nNest_C<-round(sum(predictions$z[,3]))\n```\n\nOur estimates of abundance in this example are `r Nest_A` for species A,\n`r Nest_B` for species B, and `r Nest_C` for species C.\n\n## *Estimating uncertainty*\n\nAgain we can replicate our bootstrapping methods we used to estimate\nuncertainty in prior methods.\n\n```{r,warnings=FALSE,message=FALSE,results=\"hide\"}\n#bootstrapping boogie\niterations<-100\nresults<-data.frame()\n\nfor(j in 1:iterations){\n  d <- sonar_data[sample(nrow(sonar_data), replace = TRUE), ]\n  predictions <- predict(model_3, d[, c(\"length\", \"num_date\")])\n  d$species_predicted <- factor(predictions$classification,\n                                       levels = 1:3, labels = c(\"A\",\"B\",\"C\"))\n  \n  N_A<-sum(predictions$z[,1])\n  N_B<-sum(predictions$z[,2])\n  N_C<-sum(predictions$z[,3])\n  iter<-data.frame('iteration'=j,\"A\"=N_A[1],\"B\"=N_B[1],\"C\"=N_C[1])\n  results<-results%>%rbind(iter)\n}\n\n#iteration total estimates\niter_totals<-results%>%\n  group_by(iteration)%>%\n  dplyr::summarise(A=sum(A),\n                   B=sum(B),\n                   C=sum(C))\n\n#bounds\nA_stats <- quantile(iter_totals$A, probs = c(0.025, 0.975))\nB_stats <- quantile(iter_totals$B, probs = c(0.025, 0.975))\nC_stats <- quantile(iter_totals$C, probs = c(0.025, 0.975))\n```\n\nThe above results show that our estimate of total abundance of species A\nin our sonar counts is `r Nest_A` with 95% CI \\[`r ceiling(A_stats[1])`,\n`r ceiling(A_stats[2])`\\], a count of `r Nest_B` with 95% CI\n\\[`r ceiling(B_stats[1])`, `r ceiling(B_stats[2])`\\] for species B, and\na count of `r Nest_C` with 95% CI \\[`r ceiling(C_stats[1])`,\n`r ceiling(C_stats[2])`\\] for species C.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"gmm.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.433","editor":"visual","theme":"cosmo","title":"Gaussian Mixed Modelling","bibliography":["references/references.bib"],"link-citations":true},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}