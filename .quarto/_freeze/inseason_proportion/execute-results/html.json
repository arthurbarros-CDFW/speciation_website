{
  "hash": "b7cb3a85b5e7d8e6fbc0b4d10ed072df",
  "result": {
    "markdown": "---\ntitle: \"In-season species proportion\"\n\nbibliography: references/references.bib\nlink-citations: TRUE\n---\n\n\nLet's use our simulated data `daily_sonar` data again, however this time\nour auxiliary counts will be from the same year as our sonar data. This\nmethod determines the proportion of counts for each species in a given\nperiod of sonar data based on the proportions seen in a proximate\n(spatially and temporally) auxiliary data set. This is similar to\nmethods used in @Nolan2023, @Mora2018, and suggested in @Boughton2022.\nThe following simulated data is produced in the same manner as the\nhistorical auxiliary data we created, but this time representing count\ndata collected the same season as our sonar data.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)  # For reproducibility\n# Simulate counts around the peaks using normal distributions\nh_countsA <- round(rnorm(400, mean = as.numeric(as.Date(\"2023-11-20\")),\n                         sd = 20))\nh_countsB <- round(rnorm(325, mean = as.numeric(as.Date(\"2024-01-10\")),\n                         sd = 22))\n\n# Create dataframes, add species columns, and combine in one step\ndate_counts <- bind_rows(\n  as.data.frame(table(as.Date(h_countsA, origin = \"1970-01-01\"))) %>%\n    rename(date = Var1, Count = Freq) %>%\n    mutate(aux_species = \"A\"),\n  as.data.frame(table(as.Date(h_countsB, origin = \"1970-01-01\"))) %>%\n    rename(date = Var1, Count = Freq) %>%\n    mutate(aux_species = \"B\")\n)\n\n# Convert Date column and bin by week\ndate_counts <- date_counts %>%\n  mutate(date = as.Date(date),\n         Week = cut(date, breaks = \"week\", start.on.monday = TRUE))\n\n# Aggregate the counts by week and species\naux_current <- date_counts %>%\n  group_by(Week, aux_species) %>%\n  summarise(Total_Count = sum(Count), .groups = \"drop\") %>%\n  mutate(Week = as.Date(Week))  # Convert Week to Date type for plotting\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Plot showing species counts of a current auxiliary catch data set.](inseason_proportion_files/figure-html/hatchery_sim_plot_current-1.png){width=672}\n:::\n:::\n\n\nAgain we can calculate weekly species proportions for our auxiliary\ncount data using the methods detailed in the last section:\n\n\n::: {.cell}\n\n```{.r .cell-code}\naux_proportions <- aux_current %>%\n  group_by(Week) %>%\n  mutate(total_n = sum(Total_Count),\n         proportion = Total_Count / total_n) %>%\n  ungroup()\n```\n:::\n\n\nWe can utilize those weekly proportions from the proximate auxiliary\ncounts to assign weekly proportions of species to our sonar count data.\nThis is based on the assumption that the proportion of a given species\nin the sonar count is equal to the proportion of that species in our\nauxiliary data:\n\n$$\nP_{A,i} = \\frac{N_{A,i}}{N_i}\n$$ {#eq-prop}\n\nWhere $P_{A,i}$ is the proportion of species A during period $i$,\n$N_{A,i}$ is the number of fish of species A captured in our auxiliary\ndata set during period $i$, and $N_i$ is the total number of fish\ncaptured in our auxiliary data during period $i$. A side note: if the\nauxiliary data is some distance away from the sonar counts, we may try\nand utilize a lag-time in our proportion estimates, so that the catch at\nthe hatchery during week $i$ is representative sonar data from week\n$i-1$.\n\nStart by joining our simulated `daily_sonar` data to the\n`hatchery_proportions` data we produced.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndaily_sonar_nospecies<-daily_sonar%>%\n  group_by(date,Week)%>%\n  summarise(Net_Movement=sum(Net_Movement))\ndaily_sonar_proportions<-daily_sonar_nospecies%>%\n  left_join(aux_proportions,by=\"Week\")\n```\n:::\n\n\nIf you take a look at the `daily_sonar_proportions` data, you'll see\nthat our sonar movement data starts and ends several days outside the\nhatchery count date range. To deal with this we can assume that sonar\nmovement counts before the first week of hatchery data are species A,\nand movement counts after the last week of hatchery data are species B.\nWe can do that with the following code chunk:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify the first and last hatch dates\nfirst_aux_week <- first(aux_proportions$Week)\nlast_aux_week <- last(aux_proportions$Week)\n\ndaily_sonar_proportions$predicted_species<-NA\n# Assign species based on date conditions\ndaily_sonar_proportions <- daily_sonar_proportions %>%\n  mutate(\n    predicted_species = case_when(\n      is.na(predicted_species) & Week < first_aux_week ~ \"A\",\n      is.na(predicted_species) & Week > last_aux_week ~ \"B\",\n      is.na(predicted_species) ~ aux_species \n    ),\n    proportion = if_else(is.na(proportion), 1, proportion)\n  )\ndaily_sonar_proportions<-daily_sonar_proportions%>%\n  mutate(assigned_count=round(proportion*Net_Movement))\n```\n:::\n\n\nNext we can assign a proportion of each days sonar movement count to\neither of the two species based on the proportion of that species from\nthe hatchery count data for that week.\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\nweekly_sonar_proportions<-dplyr::select(daily_sonar_proportions,\n                                       Week,date,\n                                       species=predicted_species,\n                                       assigned_count)\n```\n:::\n\n\nPlotting the above data, we get results similar to what we had with the\nin-season cutoff, but here we have proportional data that shows overlap\nin species counts, so that we aren't assuming there is no overlap in run\ntiming.\n\n\n::: {.cell warnings='false'}\n::: {.cell-output-display}\n![Plot showing species assignments of sonar data using a proportional method](inseason_proportion_files/figure-html/prop_assign_plot-1.png){width=672}\n:::\n:::\n\n\nThe above method of speciation is still relatively simple in it's\nexecution, and relies on the following assumptions:\n\n-   All fish passing through the sonar site are either one of two\n    species.\n\n-   Auxiliary catch proportions are representative of the true\n    proportions seen in sonar data.\n\nNow we can use the speciation above to estimate our seasonal abundance\nfor each of the two species:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nN_est2<-weekly_sonar_proportions%>%\n  group_by(species)%>%\n  summarise(total=sum(assigned_count))\nN_est2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 2 Ã— 2\n  species total\n  <chr>   <dbl>\n1 A        1057\n2 B         943\n```\n:::\n:::\n\n\nReferencing our original simulated sonar data, we know we had 1000\nindividuals for species A and 850 for species B, so our accuracy in our\nend abundance estimates is pretty good. However we won't know the true\nnumbers when using real data, so we'll need a way to estimate\nuncertainty.\n\n## *Estimating uncertainty*\n\nWe can expand upon the in-season proportion method created above by\nusing iterative \"bootstrapping\" to generate confidence intervals of our\nestimates. This is done iteratively re-sampling our auxiliary hatchery\ncount data to assign species counts to our sonar data. This process is\nrepeated for a set number of iterations to generate variance, which is\nthen used to estimate confidence intervals. One advantage of\nbootstrapping is that it does not rely on assumptions of normality,\nmaking it a robust method for data with unknown distributions.\n\nWe can begin the bootstrapping by writing a function that takes our\nauxiliary species count data (`aux_proportions`) for each week of the\nsonar survey and randomly samples the counts to assign species to the\nsonar movement data. (@fig-bootstrapping_concept).\n\n![Conceptual figure of bootstrapping weekly auxiliary count data to\nproduce variance in species\nassignments.](images/img_bootstrap.png){#fig-bootstrapping_concept\nfig-align=\"center\"}\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\nsonar_sampling <- function(daily_sonar, aux_data) {\n  weeks <- unique(daily_sonar$Week)\n  \n  #estimate weekly proportions of auxiliary species counts\n  aux_proportions <- aux_data %>%\n    group_by(Week) %>%\n    mutate(total_n = sum(Total_Count),\n         proportion = Total_Count / total_n) %>%\n    ungroup()\n  \n  # Predefine data frame for results\n  weekly_sonar <- vector(\"list\", length(weeks))\n  \n  # Get boundary weeks for aux_proportions\n  first_aux_week <- min(aux_proportions$Week)\n  last_aux_week <- max(aux_proportions$Week)\n  \n  for (i in seq_along(weeks)) {\n    week <- weeks[i]\n    \n    # Get auxiliary data for the current week\n    wk_sp <- aux_proportions %>% filter(Week == week)\n    wk_sonar <- daily_sonar %>% filter(Week == week)\n    \n    # Create species vector or default to \"A\" or \"B\" based \n    #on week range this is for weeks of sonar data\n    #that don't match up with weeks of aux data\n    sp_vec <- if (nrow(wk_sp) > 0) {\n      rep(wk_sp$aux_species, wk_sp$Total_Count)\n    } else if (week < first_aux_week) {\n      \"A\"\n    } else if (week > last_aux_week) {\n      \"B\"\n    } else {\n      character(0)\n    }\n    \n    # Perform sampling and count occurrences of each species\n    if (length(sp_vec) > 0) {\n      samp_sonar <- sample(sp_vec, sum(wk_sonar$Net_Movement),\n                           replace = TRUE)\n      samp_A <- sum(samp_sonar == \"A\")\n      samp_B <- sum(samp_sonar == \"B\")\n    } else {\n      samp_A <- 0\n      samp_B <- 0\n    }\n    \n    # Store results in a list to avoid repeated data frame binding\n    weekly_sonar[[i]] <- data.frame(Week = week, A = samp_A, B = samp_B)\n  }\n  \n  # Bind the list into a single data frame after the loop\n  weekly_sonar <- do.call(rbind, weekly_sonar)\n  return(weekly_sonar)\n}\n```\n:::\n\n\nThe above function takes our simulated data `daily_sonar` and `aux_data`\nand does the following:\n\n-   Makes a vector listing all the weeks of survey.\n\n-   Calculates the species proportions for each week of the auxiliary\n    data.\n\n-   Runs a `for` loop that assigns a species to sonar counts by sampling\n    from corresponding weeks of the auxiliary data.\n\n-   For weeks of sonar data outside of the range of aux data, the loop\n    assigns species A to early counts, and species B to later counts.\n\nWe can now use the above `sonar_sampling` function to \"bootstrap\" our\ndata to estimate the distribution of our species counts generated with\nsome sampling error. For this example, we repeat the sampling process\nusing our function for 25 iterations in a simple `for` loop. When\nrunning bootstrapping yourself, you'll likely want to aim for 500 to\n1000 iterations, which will take quite a bit longer to run.\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\n#bootstrapping boogie\niterations<-100\nresults<-data.frame()\n\nfor(j in 1:iterations){\n  iter<-data.frame('iteration'=j)\n  d<-iter%>%cbind(sonar_sampling(daily_sonar,aux_current))\n  results<-results%>%rbind(d)\n}\n\nhead(results)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  iteration       Week  A B\n1         1 2023-08-28  1 0\n2         1 2023-09-04  3 0\n3         1 2023-09-11  5 0\n4         1 2023-09-18 11 0\n5         1 2023-09-25 19 0\n6         1 2023-10-02 33 0\n```\n:::\n:::\n\n\nThe `results` output of our bootstrapping shows weekly species counts\nfor sonar data produced by our random sampling of auxiliary data. We can\ngroup the results together by iteration for an estimate of species total\nfor each season, and then calculate lower and upper 95% confidence\nintervals using the `quantile()` call.\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\n#iteration total estimates\niter_totals<-results%>%\n  group_by(iteration)%>%\n  dplyr::summarise(A=sum(A),\n                   B=sum(B))\n\n#bounds\nA_stats <- quantile(iter_totals$A, probs = c(0.025, 0.975))\nB_stats <- quantile(iter_totals$B, probs = c(0.025, 0.975))\nA_mean<-mean(iter_totals$A)\nB_mean<-mean(iter_totals$B)\n```\n:::\n\n\nUsing the above we see that our **estimate of total abundance of species\nA in our sonar counts is 1057 with 95% CI\n\\[1043, 1078\\] and a count of\n943 with 95% CI \\[922,\n958\\] for species B**.\n\nWe can also estimate 95% confidence intervals for our weekly species\nassignments using the results output.\n\n\n::: {.cell warnings='false'}\n\n```{.r .cell-code}\n# Weekly total estimates with confidence intervals\nweekly_results <- results %>%\n  group_by(Week) %>%\n  summarise(\n    A_mean = mean(A),\n    A_lb = quantile(A, probs = 0.025),\n    A_ub = quantile(A, probs = 0.975),\n    B_mean = mean(B),\n    B_lb = quantile(B, probs = 0.025),\n    B_ub = quantile(B, probs = 0.975),\n    .groups = \"drop\"\n  ) %>%\n  pivot_longer(\n  cols = 2:7,\n  names_to = c(\"Species\", \".value\"),\n  names_sep = \"_\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Plot showing species assignments of sonar data using proportional bootstrapping to estimate confidence intervals (95%).](inseason_proportion_files/figure-html/boots_2.5_plot-1.png){width=672}\n:::\n:::\n\n\nThe above figure shows that during periods of run-timing overlap, our\nprecision in estimation of species assignment decreases substantially.\nThe more overlap in run-timing, the more bias we can expect in our\nspeciation.\n\nThe above method of speciation provides a straightforward approach for\nleveraging more contemporary auxiliary data to infer species composition\nin sonar detection studies. Using the species proportions from this\nauxiliary data set we assign species proportions to sonar data, and can\niteratively resample the data through \"bootstraping\" to estimate\nconfidence intervals. Key assumptions to realize when utilizing this\nmethod are:\n\n-   All fish being speciated are either one of two species.\n\n-   Species proportions in the auxiliary data is representative of the\n    fish community at the sonar site.\n\nWhen considering auxiliary data sets to use for informing species\napportionment, the more proximate the data to the sonar site, the more\naccurate species assignments will likely be.\n\n",
    "supporting": [
      "inseason_proportion_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}