{
  "hash": "c63e9a5952522310877deb8f44086a36",
  "result": {
    "markdown": "---\ntitle: \"Binomial Regression\"\n\nbibliography: references/references.bib\nlink-citations: TRUE\n---\n\n::: {.cell}\n\n:::\n\n\nThe more auxiliary data we have available to us, the more complex, and\nhopefully accurate, of a model we can use to assign species to our sonar\ndata. Let's add some variables to our auxiliary data set, notably fish\nlength (cm) and daily flow data. For our example we'll just use one year\nof simulated auxiliary data, but you could use multiple years of\nauxiliary data to model speciation. We'll use similar methods as before,\nand can visualize the simulated data that we'll use here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#create new simulated auxiliary length, date, and flow data.\nset.seed(42)  # For reproducibility\n#lengths\nlengths_A <- round(rnorm(400, mean=100, sd=15),2)\nlengths_B <- round(rnorm(325, mean=80, sd=15),2)\n\n#dates\ndates_A <- round(rnorm(400,mean = as.numeric(as.Date(\"2023-11-20\")), sd = 20))\ndates_B <- round(rnorm(325,mean = as.numeric(as.Date(\"2024-01-10\")), sd = 22))\n\n#make dataframe\naux_data <- data.frame(\n  length = c(lengths_A, lengths_B),\n  date = round(as.Date(c(dates_A,dates_B), origin = \"1970-01-01\")),\n  species = factor(rep(c(\"A\", \"B\"), times=c(400,325)))\n)\n\n#flow\nstart_date <- as.Date(paste(year(min(aux_data$date)),\"01\",\"01\",sep=\"-\"))\nend_date <- as.Date(paste(year(max(aux_data$date)),\"12\",\"31\",sep=\"-\"))\ndates <- seq.Date(start_date, end_date, by = \"day\")\n\ndays_in_period <- length(dates)\nmax_flow <- 1000  # maximum flow in cfs\nmin_flow <- 100    # minimum flow in cfs\n\n# Create a sinusoidal flow pattern to simulate seasonal variation\nflow_pattern <- (max_flow - min_flow) / 2 * \n  sin(2 * pi * (1:days_in_period -20) / 365) + \n  (max_flow + min_flow) / 2\n\n# Create a random noise process using an auto-regression model\n# rho=level of autocorrelation\nrho <- 0.9  # autocorrelation parameter; \n#higher values give smoother transitions\n\nac_noise <- numeric(days_in_period)\nac_noise[1] <- rnorm(1, mean = 0, sd = 100)  # initial noise value\nfor (i in 4:days_in_period) {\n  ac_noise[i] <- rho * ac_noise[i - 1] + rnorm(1, mean = 0, sd = 100)\n}\nflow_data <- flow_pattern + ac_noise\n\n# Ensure no flow goes below the minimum flow\nflow_data[flow_data < 10] <- 10\n\n# Create a dataframe for plotting and analysis\nflow_df <- data.frame(\n  date = as.Date(dates),\n  Flow_cfs = flow_data\n)\n\naux_data<-aux_data%>%\n  dplyr::left_join(flow_df,by=\"date\")\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Plots showing date, length, and flow for expanded simulated auxiliary data.](binomial_regression_files/figure-html/regression_aux_plot-1.png){width=480}\n:::\n:::\n\n\nWe can use this auxiliary data to build a binomial **logistic\nregression** model, in which our response variable is the probability of\nthe observed fish being one of two species. This logistic regression\nmethod can allow us to incorporate additional covariates beyond just\ndate of capture. For our auxiliary data we can represent this model with\nthe following equation:\n\n$$ \nP(y=A)=\\frac{1}{1+e^{\\beta_0+\\beta_1*x_{1,y}+\\beta_2*x_{2,y}+....+\\beta_M*x_{M,y}}}\n$$ {#eq-binom_reg}\n\nWhere $P(y=A)$ is the probability of a given fish $y$ being species $A$,\n$\\beta$ is the regression coefficient for a given explanatory variable,\nand $M$ is the total number of explanatory variables. Here we'll be\nusing three potential explanatory variables: date of observation, fish\nlength (cm), and average daily water flow (cfs). This is similar to\nmethods outlined in @Metheny2012, where models were developed using live\nfish observations from the USGS Cooperative Fish and Wildlife Research\nUnit on Redwood Creek from 2009-2010.\n\nWe can build this model and validate it before we attempt to assign\nspecies to any sonar data. We can start by assigning a species index to\neach record, of 1 if the species was A, 0 if B. Then we can split our\ndata into a \"training\" data set to build the model on, and another data\nset to test the model on. We'll use the `createDataPartition()` function\nfrom the `caret` package to split our auxiliary data into the\n`train_data` data frame comprised of 70% of our records, and a\n`test_data` data frame comprising the other 30%.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naux_index<-aux_data%>%\n  mutate(species_index=ifelse(aux_data$species==\"A\",1,0))\n\n# Split data into training and testing sets\nset.seed(123) #set seed for repeatability\n#create training data set with 70% of data\ntrain_index <- createDataPartition(aux_index$species,\n                                   p = 0.7, list = FALSE) \ntrain_data <- aux_index[train_index, ]\ntest_data <- aux_index[-train_index, ]\n```\n:::\n\n\nNow that we have our training and testing data sets, we can build our\nmodel with the `glm()` function, structuring it off of @eq-binom_reg,\nand setting as a binomial regression by setting `family=binomial`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_1 <- glm(species_index ~ as.numeric(date) + length + Flow_cfs,\n               data = train_data, family = binomial)\nsummary(model_1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nglm(formula = species_index ~ as.numeric(date) + length + Flow_cfs, \n    family = binomial, data = train_data)\n\nDeviance Residuals: \n     Min        1Q    Median        3Q       Max  \n-2.45746  -0.13241   0.03463   0.23579   2.96957  \n\nCoefficients:\n                   Estimate Std. Error z value Pr(>|z|)    \n(Intercept)       2.226e+03  2.656e+02   8.383  < 2e-16 ***\nas.numeric(date) -1.134e-01  1.350e-02  -8.399  < 2e-16 ***\nlength            8.964e-02  1.423e-02   6.299 2.99e-10 ***\nFlow_cfs         -1.264e-03  9.319e-04  -1.356    0.175    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 698.91  on 507  degrees of freedom\nResidual deviance: 194.90  on 504  degrees of freedom\nAIC: 202.9\n\nNumber of Fisher Scoring iterations: 7\n```\n:::\n:::\n\n\nIf we look at the summary output of our model, we can see that both\nlength and date have significant effects on the probability of a fish\nbeing species A or species B. The flow covariate was not significant in\nspecies ID, so we can actually drop it from our model moving forward.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_1 <- glm(species_index ~ as.numeric(date) + length,\n               data = train_data, family = binomial)\n```\n:::\n\n\nWe then use the `predict()` function to predict the species assignments\nof the `test_data` using the model we created. This assigns a\nprobability of each test record being species A, which we can then round\nand assign a value of 1 if that the probability is greater then 50%, and\n0 otherwise. This process is a \"threshold\" assignment, in which we\ncategorize our predicted probabilities into binary classes. Then those\npredictions are rejoined to the `test_data`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Predictions\npredictions <- predict(model_1, newdata = test_data, type = \"response\")\npredicted_classes <- ifelse(predictions > 0.5, 1, 0)\nspecies_predicted<-ifelse(predicted_classes==1,\"A\",\"B\")\n\ntest_data<-test_data%>%cbind(species_predicted)\n```\n:::\n\n\nWe can now compare the predicted species for the `test_data` to the\nactual species, and see how accurate our species identification was\nusing this model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Accuracy\naccuracy <- sum(species_predicted == test_data$species) / nrow(test_data)\nprint(paste(\"Accuracy:\", round(accuracy, 3)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Accuracy: 0.917\"\n```\n:::\n:::\n\n\nAbove we can see our estimate accuracy in determining if a given fish\nwas species A or B was 0.917. Of course, for our purpose\nwe are not necessarily interested in whether or not a given sonar fish\nimage is one species or another. What we are most interested in is\nabundances of each species based on our sonar data.\n\nTo figure out how much error there is in our estimates of the abundance\nfor each species we can find the true count for each species in our\n`test_data` and compare it to the abundance estimate based on the\nspecies predictions from the model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nNtrue_A<-sum(test_data$species==\"A\")\nNtrue_B<-sum(test_data$species==\"B\")\n\nNest_A<-sum(test_data$species_predicted==\"A\")\nNest_B<-sum(test_data$species_predicted==\"B\")\n\nerror_A <- abs(Nest_A - Ntrue_A)\nerror_B <- abs(Nest_B - Ntrue_B)\n\nrel_error_A <- error_A / Ntrue_A\nrel_error_B <- error_B / Ntrue_B\n  \nMAPE <- mean(c(rel_error_A, rel_error_B)) * 100\n```\n:::\n\n\nWe see above that testing our model shows an error of\n3.729 % in the our species abundance predictions.\n\nNext we'll want to do the above many more times in an iterative process\nsimilar to the bootstrapping we've already done, and we can use our\naverage relative error in abundance estimates as our benchmark.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(Sys.time()) #reset seed\niterations=100\nresults<-data.frame()\nfor(i in 1:iterations){\n  train_index <- createDataPartition(aux_index$species,\n                                     p = 0.7, list = FALSE) \n  train_data <- aux_index[train_index, ]\n  test_data <- aux_index[-train_index, ]\n  model_iter <- glm(species_index ~ as.numeric(date) + length,\n               data = train_data, family = binomial)\n  predictions <- predict(model_iter, \n                         newdata = test_data, type = \"response\")\n  predicted_classes <- ifelse(predictions > 0.5, 1, 0)\n  species_predicted<-ifelse(predicted_classes==1,\"A\",\"B\")\n\n  test_data<-test_data%>%\n    cbind(species_predicted<-ifelse(predicted_classes==1,\"A\",\"B\"))\n  accuracy <- sum(species_predicted == test_data$species)/nrow(test_data)\n  \n  Ntrue_A<-sum(test_data$species==\"A\")\n  Ntrue_B<-sum(test_data$species==\"B\")\n\n  Nest_A<-sum(test_data$species_predicted==\"A\")\n  Nest_B<-sum(test_data$species_predicted==\"B\")\n\n  error_A <- abs(Nest_A - Ntrue_A)\n  error_B <- abs(Nest_B - Ntrue_B)\n\n  rel_error_A <- error_A / Ntrue_A\n  rel_error_B <- error_B / Ntrue_B\n  \n  MAPE <- mean(c(rel_error_A, rel_error_B)) * 100\n  \n  d<-data.frame(\"accuracy\"=accuracy,\"MAPE\"=MAPE)\n  results<-results%>%rbind(d)\n}\n```\n:::\n\n\nBased on the above model training and iterative testing, we see our\nmodel predicted the species of our test data with an average accuracy of\n0.911 and an average error in abundance\nestimates of 3.113 %.\n\nWe've trained and tested our model, and have some benchmarks of accuracy\nin species ID and abundance estimates. Next we'll have to generate a new\nsonar data set for this example that will incorporate length and flow\ndata linked to our sonar counts. We can simulate this data similar to\nhow we've done for our prior two examples here:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#Simulate some example sonar data\nset.seed(123)  # For reproducibility\n#lengths\nlengths_A <- round(rnorm(1000, mean=100, sd=15),2)\nlengths_B <- round(rnorm(850, mean=80, sd=15),2)\n\n#dates\ndates_A <- round(rnorm(1000,mean=as.numeric(as.Date(\"2023-11-10\")),sd=22))\ndates_B <- round(rnorm(850,mean=as.numeric(as.Date(\"2024-01-12\")),sd=20))\n\n#make dataframe\nsonar_data <- data.frame(\n  length = c(lengths_A, lengths_B),\n  date = round(as.Date(c(dates_A,dates_B), origin = \"1970-01-01\"))\n)\n\n#join in flow data\nsonar_data<-sonar_data%>%\n  dplyr::left_join(flow_df,by=\"date\")\n```\n:::\n\n\nNext we'll retrain our model using the entire auxiliary data set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmodel_1<-glm(species_index ~ as.numeric(date) + length + Flow_cfs,\n             data = aux_index, family = binomial)\n```\n:::\n\n\nBased on the summary output for our model, we see that length and date\nare both strong predictors of species, while the flow covariate is not\nsignificant in predicting species.\n\nNext we can use our `model_1` to assign species to our sonar data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredictions <- predict(model_1, newdata = sonar_data, type = \"response\")\npredicted_classes <- ifelse(predictions > 0.5, 1, 0)\n\nsonar_predicted<-sonar_data%>%cbind(predicted_classes)\nsonar_predicted$species=ifelse(sonar_predicted$predicted_classes==1,\"A\",\"B\")\n```\n:::\n\n\nPlot the speciation results.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stderr}\n```\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n`stat_bin()` using `bins = 30`. Pick better value with `binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![Plot showing species assignments of sonar data using binomial logistic regression.](binomial_regression_files/figure-html/model1_plot-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nN_est3<-sonar_predicted%>%\n  group_by(species)%>%\n  tally()\n```\n:::\n\n\nOur final estimates of abundance in this example are 1038 for\nspecies A and 812 for species B.\n\n## *Estimating uncertainty*\n\nWe can utilize a bootstrapping method again to incorporate variance in\nour sonar data and estimate confidence intervals for our final species\nabundance estimates. We'll do this by iteratively rebuilding our\nlogistic model by resampling our sonar data. The following chunk uses a\nfor-loop to sample, with replacement, our `sonar_data`, and then assign\nspecies using `model_1` to the new data set. We then calculate new\nestimates of abundance for each species with the same methods we just\nused.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#bootstrapping boogie\niterations<-100\nresults<-data.frame()\n\nfor(j in 1:iterations){\n  d <- sonar_data[sample(nrow(sonar_data), replace = TRUE), ]\n  p_boot <- predict(model_1, newdata = d, type = \"response\")\n  p_classes <- ifelse(p_boot > 0.5, 1, 0)\n\n  sonar_boot<-sonar_data%>%cbind(p_classes)\n  sonar_boot$species=ifelse(sonar_boot$p_classes==1,\"A\",\"B\")\n  N_A<-length(which(sonar_boot$species==\"A\"))\n  N_B<-length(which(sonar_boot$species==\"B\"))\n  iter<-data.frame('iteration'=j,\"A\"=N_A[1],\"B\"=N_B[1])\n  results<-results%>%rbind(iter)\n}\n```\n:::\n\n\nWe can use the `results` output from above to calculate our 95%\nconfidence intervals using the `quantile()` call:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#iteration total estimates\niter_totals<-results%>%\n  group_by(iteration)%>%\n  dplyr::summarise(A=sum(A),\n                   B=sum(B))\n\n#bounds\nA_stats <- quantile(iter_totals$A, probs = c(0.025, 0.975))\nB_stats <- quantile(iter_totals$B, probs = c(0.025, 0.975))\n```\n:::\n\n\nThe above results show that our estimate of total abundance of species A\nin our sonar counts is 1038 with 95% CI\n\\[993, 1069\\] and a count of\n812 with 95% CI \\[782,\n858\\] for species B.\n\nLogistic regression is a fairly simple method that can incorporate\nmultiple covariates to help in assigning species to sonar counts. A good\nadvantage of this method is we can train and test our logistic model\nwith our auxiliary data to estimate accuracy, and again bootstrap the\nsonar data to assign confidence intervals. Key assumption for the\nbinomial logistic regression include:\n\n-   All fish being speciated either one of two species.\n\n-   The dates of run times and lengths of fish observed in the auxiliary\n    data are representative of the fish observed in sonar imaging.\n\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "binomial_regression_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}